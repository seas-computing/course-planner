import {
  Injectable,
  Inject,
  Logger as NestLogger,
} from '@nestjs/common';
import { Logger as TypeORMLogger } from 'typeorm';
import winston, { Logger as WinstonLogger } from 'winston';
import { ConfigService } from 'server/config/config.service';
import { StreamOptions } from 'morgan';
import { TYPEORM_LOG_LEVEL, LOG_LEVEL } from 'common/constants';
import util from 'util';

/**
 * Represents a value that can be directly written to the logs, without needing
 * to go through util.inspect
 */
type Writable = string | number;

/**
 *  Represents more complex objects that should be passed through util.inspect
 *  before they can be meaningfully written to the console.
 */
export type Inspectable = Record<string, unknown>
| Record<string, unknown>[]
| Writable[]
| unknown[];

/**
 * A general type for any data that can be logged by the logger
 */

export type Loggable<T> = T extends Writable
  ? Writable
  : T extends Record<Writable, unknown>
    ? Inspectable
    : unknown;

/**
 * Describes the info object expected by Winston's transform functions, adding
 * the timestamp and label fields
 */
interface WinstonInfo extends winston.Logform.TransformableInfo {
  /** The ISO timestamp provided by winston.format.timestamp() */
  timestamp: string,
  /** An optional label indicating the source of the message */
  label?: string,
}

/**
 * Provides predefined labels for the major libraries in the project, for use
 */
export enum LABEL {
  NEST = 'NestJS',
  TYPEORM = 'TypeORM',
  EXPRESS = 'Express',
}

/**
 * Computes the longest log level to use in padding out the log messages
 * Defined outside the service since this should not change at runtime
 *
 */
const widestLog = Math.max(
  ...Object.values(LOG_LEVEL).map(
    (lvl: string): number => lvl.length
  )
);

/**
 * An injectable service that instantiates a Winston logger, and overwrites the
 * existing Nest logging methods with Winston's methods.
 *
*/

@Injectable()
class LogService extends NestLogger implements TypeORMLogger {
  /**
   * The winston instance that will be used inside the service
   */
  private readonly logger: WinstonLogger;

  /**
   * The config service
   */
  private readonly config: ConfigService;

  public constructor(
  @Inject(ConfigService) config: ConfigService
  ) {
    super();
    this.config = config;

    const logFormat = this.logFormat
      .bind(this) as (info: WinstonInfo) => string;

    this.logger = winston.createLogger({
      level: config.logLevel,
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf(logFormat)
      ),
      transports: [
        new winston.transports.Console(),
      ],
    });
  }

  /**
     * Define a custom log format:
     * TIMESTAMP [LEVEL]    (LABEL) MESSAGE
   */
  public logFormat(info: WinstonInfo): string {
    const fmtLevel = `[${info.level.toUpperCase()}]`.padEnd(widestLog + 2);
    return `${info.timestamp} ${fmtLevel} (${info.label}) ${info.message}`;
  }

  /**
   * Helper function that wraps util.inspect and passes in our defined options
   */
  private inspect<T>(obj: Loggable<T>): string {
    return util.inspect(obj, {
      depth: Infinity,
      colors: this.config.isDevelopment,
      compact: false,
    });
  }

  /**
   * Log errors thrown in the application.
   * For compatibility with Nest, this method can accept a stack trace as the
   * second argument, and a label as its third.
   * Will also accept an Error as the first argument, and will print the stack
   * trace separately.
   * LOG LEVEL: 0
   */
  public error(message: Error | Writable, trace?: null, label?: Writable): void
  public error(message: Writable, trace?: string, label?: Writable): void
  public error(message: unknown, trace?: string, label?: Writable): void {
    if (message instanceof Error) {
      this.logger.error(message.message, { label });
      this.logger.error(message.stack, { label });
    } else if (trace) {
      this.logger.error(message.toString(), { label: label || LABEL.NEST });
      this.logger.error(trace, { label: label || LABEL.NEST });
    } else {
      this.logger.error(message.toString(), { label });
    }
  }

  /**
   * Handles logging query errors generated by TypeORM by passing them to our
   * error function
   */
  public logQueryError(
    error: string | Error,
    query: Writable,
    parameters?: Inspectable
  ): void {
    this.error(error, null, LABEL.TYPEORM);
    this.error(query, null, LABEL.TYPEORM);
    if (Array.isArray(parameters) && parameters.length > 0) {
      this.error(this.inspect(parameters), null, LABEL.TYPEORM);
    }
  }

  /**
   * Record issues that don't degrade the application, but may produce
   * less-desirable results.
   * LOG LEVEL: 1
   */
  public warn(message: Writable, label?: string):void {
    this.logger.warn(message.toString(), { label });
  }

  /**
   * Method used by TypeORM to flag long-running queries that could indicate
   * performance issues.
   * The threshold for slow queries is set by the `maxQueryExecutionTime`
   * in the connection options in app.module.ts
   * Messages will be passed to our warn function
   */

  public logQuerySlow(time: number, query: Writable): void {
    this.warn(`The following query took ${time}ms to run`, LABEL.TYPEORM);
    this.warn(query, LABEL.TYPEORM);
  }

  /**
   * The standard log level, used to for relaying regular information about the
   * status of the app, e.g. Nest startup messages
   * LOG LEVEL: 2
   */
  public info(message: Writable, label?: string):void {
    this.logger.info(message.toString(), { label });
  }

  /**
   * The base logging function used by Nest and TypeORM. They use different
   * formats, so if the first arugment is one of TypeORM's log levels it will
   * expect the log message to be the second argument. Otherwise, the first
   * argument will be treated as the log message, and the second argument as
   * the nest component generating the message.
   * In our implementaiton, log/info messages will go to the info stream, and
   * warnings will go to the warn stream
   */
  public log(messageOrLevel: Writable, classOrMessage: Writable): void
  public log(messageOrLevel: TYPEORM_LOG_LEVEL, classOrMessage: Writable): void
  public log(messageOrLevel: unknown, classOrMessage?: unknown):void {
    if (messageOrLevel === TYPEORM_LOG_LEVEL.LOG
        || messageOrLevel === TYPEORM_LOG_LEVEL.INFO) {
      this.info(classOrMessage.toString(), LABEL.TYPEORM);
    } else if (messageOrLevel === TYPEORM_LOG_LEVEL.WARN) {
      this.warn(classOrMessage.toString(), LABEL.TYPEORM);
    } else {
      this.info(
        messageOrLevel.toString(),
        `${LABEL.NEST}#${classOrMessage.toString()}`
      );
    }
  }

  /**
   * Records all requests/responses handled by the application, similar to
   * Apache/nginx logs
   * LOG LEVEL: 3
   */
  public http(message: Writable, label?: string):void {
    this.logger.http(message.toString(), { label });
  }

  /**
   * Exposes a writable stream for http messages that can be used by morgan for
   * generating apache-style logs.
   */
  public get httpStream(): StreamOptions {
    return {
      write: (message: string): void => {
        this.http(message, LABEL.EXPRESS);
      },
    };
  }

  /**
   * Records more detailed information about the running application. Includes:
   *  - ID of user's associated with requests
   *  - Notifications about data read from and written to the database
   *
   *  This method will expand objects/arrays passed as arguments, such as:
   *  - Body content of POST/PUT requests
   *  - Body content returned in responses
   * LOG LEVEL: 4
   */
  public verbose<T>(message: Loggable<T>, label?: string): void {
    if (typeof message === 'string') {
      this.logger.verbose(message, { label });
    } else if (typeof message === 'number') {
      this.logger.verbose(message.toString(), { label });
    } else {
      this.logger.verbose(this.inspect(message), { label });
    }
  }

  /**
   * Provides more granual data about the execution flow of the app. Only intended for use in development
   * Like [[verbose]], this method will expand objects/arrays
   * LOG LEVEL: 5
   */
  public debug<T>(message: Loggable<T>, label?: string):void {
    if (typeof message === 'string') {
      this.logger.debug(message, { label });
    } else if (typeof message === 'number') {
      this.logger.debug(message.toString(), { label });
    } else {
      this.logger.debug(this.inspect(message), { label });
    }
  }

  /**
   * Logs every query run by TypeORM, with parameters
   * Will write a notification to the verbose stream
   * Will write the query and parameters to the debug stream
   */
  public logQuery(query: Writable, parameters?: Inspectable): void {
    this.verbose('Running query against database', LABEL.TYPEORM);
    this.debug(query, LABEL.TYPEORM);
    if (Array.isArray(parameters) && parameters.length > 0) {
      this.debug(this.inspect(parameters), LABEL.TYPEORM);
    }
  }

  /**
   * Logs messages from the TypeORM migration process.
   * Will write a notification to our verbose stream
   * Will log the full migration message to our debug stream
   */
  public logMigration(message: Writable): void {
    this.verbose('Running migration process', LABEL.TYPEORM);
    this.debug(message, LABEL.TYPEORM);
  }

  /**
   * Logs messages from the TypeORM schema building process.
   * Will write a notification to our verbose stream
   * Will log the full schema build message to our debug stream
   */
  public logSchemaBuild(message: Writable): void {
    this.verbose('Running schema build process', LABEL.TYPEORM);
    this.debug(message, LABEL.TYPEORM);
  }
}

export { LogService };
